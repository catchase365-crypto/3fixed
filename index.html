<!-- START OF FILE: 3x3_Fixed_Core_Edition.html -->
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ä¸‰é˜¶Â·èŠ±è“‰é”</title>
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #050505;
            font-family: "Microsoft YaHei", sans-serif; user-select: none;
        }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10; }
        h1 { 
            margin: 0; color: #d4af37; letter-spacing: 4px; font-size: 28px; font-weight: bold;
            text-shadow: 0 2px 15px rgba(212, 175, 55, 0.5);
            border-bottom: 1px solid rgba(212, 175, 55, 0.3); padding-bottom: 5px;
        }
        p { font-size: 12px; color: #886b4b; margin: 5px 0 10px 0; letter-spacing: 1px; }

        /* è®¡æ—¶å™¨æ ·å¼ */
        #timer-display {
            position: absolute; 
            top: 20px; 
            right: 20px; 
            z-index: 10; 
            pointer-events: none;
            color: #d4af37;
            font-size: 24px;
            font-weight: bold;
            padding: 8px 12px;
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            background: rgba(15, 15, 15, 0.6);
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        .color-legend { display: flex; gap: 5px; margin-top: 8px; }
        .legend-dot { width: 8px; height: 8px; border-radius: 50%; border: 1px solid #444; }

        .controls {
            position: absolute; bottom: 40px; width: 100%;
            display: flex; justify-content: center; gap: 25px;
            pointer-events: auto; z-index: 20;
        }
        button {
            background: rgba(15, 15, 15, 0.9); backdrop-filter: blur(10px);
            border: 1px solid #5c4033; color: #d4af37;
            padding: 12px 32px; font-size: 14px; border-radius: 25px; 
            cursor: pointer; transition: 0.3s; text-transform: uppercase; letter-spacing: 2px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5); outline: none; font-weight: bold;
        }
        button:hover { background: #2e2018; border-color: #ffd700; color: #fff; transform: translateY(-2px); }
        button:active { transform: scale(0.96); }
        
        #victory-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: none; opacity: 0; transition: opacity 0.5s ease; z-index: 50;
            background: rgba(0,0,0,0.9);
        }
        #victory-overlay.show { opacity: 1; pointer-events: auto; }
        .win-text {
            font-size: 60px; font-weight: 300; color: #d4af37; font-family: serif;
            text-shadow: 0 0 40px rgba(212, 175, 55, 0.6); letter-spacing: 10px;
            border-top: 1px solid #d4af37; border-bottom: 1px solid #d4af37; 
            padding: 30px 0; margin-bottom: 30px;
        }

        #sound-menu {
            position: absolute; bottom: 100px; left: 50%;
            transform: translateX(-50%) scale(0);
            background: rgba(20, 12, 8, 0.98);
            border: 1px solid #5c4033; padding: 15px; border-radius: 12px;
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;
            transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto; width: 340px; z-index: 30;
            box-shadow: 0 30px 80px rgba(0,0,0,0.9); transform-origin: bottom center;
        }
        #sound-menu.open { transform: translateX(-50%) scale(1); }
        .sound-item {
            background: #1a100b; padding: 10px 5px; border-radius: 6px;
            text-align: center; color: #aa8866; font-size: 12px;
            cursor: pointer; border: 1px solid transparent; transition: 0.2s;
        }
        .sound-item.active { background: #5c4033; color: #fff; border-color: #d4af37; }
        /* è°ƒæ•´å›¾æ ‡æ ·å¼ */
        .flower-icon {
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/RoundedBoxGeometry.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="ui">
        <h1>ä¸‰é˜¶ Â· èŠ±è“‰é”</h1>
        <p>Fixed Core Edition</p>
        <p style="margin: 0; font-size: 12px; color: #d4af37; letter-spacing: 1px;">Made by Catchase</p>
        <div class="color-legend">
            <div class="legend-dot" style="background:#e6e6e6"></div>
            <div class="legend-dot" style="background:#ffd700"></div>
            <div class="legend-dot" style="background:#b90000"></div>
            <div class="legend-dot" style="background:#ff5900"></div>
            <div class="legend-dot" style="background:#009e60"></div>
            <div class="legend-dot" style="background:#0045ad"></div>
        </div>
    </div>
    
    <div id="timer-display">00:00</div>

    <div id="victory-overlay">
        <div class="win-text">æµ‘ç„¶å¤©æˆ</div>
        <div style="display:flex; gap:20px;">
            <button onclick="event.stopPropagation(); game.reset()">å½’ä½</button>
            <button onclick="event.stopPropagation(); game.shuffle()">å†ç ´ä¸€é˜µ</button>
        </div>
    </div>

    <div id="sound-menu">
        <div class="sound-item active" onclick="audioMgr.set('wood')">ğŸªµ æ²‰é¦™</div>
        <div class="sound-item" onclick="audioMgr.set('glass')">ğŸ· ç‰ç’ƒ</div>
        <div class="sound-item" onclick="audioMgr.set('mute')">ğŸ”‡ é™éŸ³</div>
    </div>

    <div class="controls">
        <button onclick="event.stopPropagation(); toggleMenu()">
            <svg width="20" height="20" viewBox="0 0 100 100" class="flower-icon">
                <!-- å®šä¹‰å…­ç§é¢œè‰²çš„æ¸å˜ä½œä¸ºèŠ±ç“£çš„å¡«å…… -->
                <defs>
                    <linearGradient id="c1" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#b90000"/><stop offset="100%" stop-color="#ff5900"/></linearGradient>
                    <linearGradient id="c2" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#ffd700"/><stop offset="100%" stop-color="#e6e6e6"/></linearGradient>
                    <linearGradient id="c3" x1="0" y1="1" x2="1" y2="0"><stop offset="0%" stop-color="#009e60"/><stop offset="100%" stop-color="#0045ad"/></linearGradient>
                </defs>
                <g transform="translate(50, 50)" stroke="#ffe082" stroke-width="4">
                    <!-- 6 ä¸ªèŠ±ç“£ (ä½¿ç”¨é¢œè‰²æ¸å˜) -->
                    <path d="M-8 0 Q-5 -30 8 0 L-8 0 Z" fill="url(#c1)" transform="rotate(0)"/>
                    <path d="M-8 0 Q-5 -30 8 0 L-8 0 Z" fill="url(#c2)" transform="rotate(60)"/>
                    <path d="M-8 0 Q-5 -30 8 0 L-8 0 Z" fill="url(#c3)" transform="rotate(120)"/>
                    <path d="M-8 0 Q-5 -30 8 0 L-8 0 Z" fill="url(#c1)" transform="rotate(180)"/>
                    <path d="M-8 0 Q-5 -30 8 0 L-8 0 Z" fill="url(#c2)" transform="rotate(240)"/>
                    <path d="M-8 0 Q-5 -30 8 0 L-8 0 Z" fill="url(#c3)" transform="rotate(300)"/>
                </g>
                <!-- èŠ±è•Š -->
                <circle cx="50" cy="50" r="10" fill="#d4af37"/>
            </svg>
            å¬è§‰
        </button>
        <button onclick="event.stopPropagation(); game.shuffle()">ğŸ”€ ä¹±é˜µ</button>
    </div>

<script>
/* 1. éŸ³é¢‘å¼•æ“ */
class SoundEngine {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.type = 'wood'; // é»˜è®¤éŸ³æ•ˆ
    }
    init() { if(this.ctx.state==='suspended') this.ctx.resume(); }
    set(key) { 
        // è®¾ç½®æ–°çš„éŸ³æ•ˆç±»å‹
        this.type=key; 
        this.init(); 
        // æ’­æ”¾é¢„è§ˆéŸ³æ•ˆï¼Œå¦‚æœä¸æ˜¯é™éŸ³
        if (key !== 'mute') {
            this.play();
        }
        document.getElementById('sound-menu').classList.remove('open'); 
    }
    
    // æ’­æ”¾å½“å‰é€‰ä¸­çš„éŸ³æ•ˆ
    play() {
        if(this.type==='mute') return;
        this.init(); 
        const t=this.ctx.currentTime;
        const osc=this.ctx.createOscillator(); 
        const g=this.ctx.createGain();
        osc.connect(g); g.connect(this.ctx.destination);
        
        if(this.type==='wood') {
            // æ²‰é¦™éŸ³æ•ˆ
            osc.type='sine'; osc.frequency.setValueAtTime(100,t); osc.frequency.exponentialRampToValueAtTime(40,t+0.15);
            g.gain.setValueAtTime(0.8,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.18);
            osc.start(t); osc.stop(t+0.2);
        } else if (this.type==='glass') {
            // ç‰ç’ƒéŸ³æ•ˆï¼šæ¸…è„†é«˜é¢‘
            osc.type='sine'; 
            osc.frequency.setValueAtTime(500,t); 
            osc.frequency.exponentialRampToValueAtTime(1200,t+0.1); 
            g.gain.setValueAtTime(0.3,t); 
            g.gain.exponentialRampToValueAtTime(0.001,t+0.15);
            osc.start(t); osc.stop(t+0.15);
        }
    }
    playWin() {
        if(this.type==='mute')return; this.init(); const t=this.ctx.currentTime;
        [196,261,329,392,523].forEach((f,i)=>{
            const o=this.ctx.createOscillator();const g=this.ctx.createGain();o.connect(g).connect(this.ctx.destination);
            o.type='sine'; o.frequency.value=f; g.gain.setValueAtTime(0,t+i*0.2);g.gain.linearRampToValueAtTime(0.2,t+i*0.2+0.1);g.gain.exponentialRampToValueAtTime(0.001,t+i*0.2+3);
            o.start(t+i*0.2);o.stop(t+i*0.2+3.5);
        });
    }
}
const audioMgr = new SoundEngine();

/* 2. çº¹ç†å·¥å‚ (åŒ…å«åŒ…é‡‘æœ¨çº¹ & é»‘é‡‘æ ¸å¿ƒ) */
const TextureFactory = {
    cache: {},
    // åˆ›å»ºå¤–å±‚æœ¨å¤´çº¹ç†
    createWood(colorHex, isInner=false) {
        const k = colorHex + (isInner?'_in':'_out');
        if(this.cache[k]) return this.cache[k];
        
        const size = 512; const canvas = document.createElement('canvas'); canvas.width=size; canvas.height=size;
        const ctx = canvas.getContext('2d');
        const col = new THREE.Color(colorHex);
        
        // å†…ä¾§é¢œè‰²äº®åº¦ (ä» #1a120b è°ƒæ•´åˆ° #3a322e)
        if(isInner) ctx.fillStyle = '#3a322e'; 
        else ctx.fillStyle = `rgb(${col.r*180}, ${col.g*180}, ${col.b*180})`;
        ctx.fillRect(0,0,size,size);
        
        // æœ¨çº¹
        ctx.globalAlpha = 0.12; ctx.globalCompositeOperation = 'multiply';
        for(let i=0;i<8000;i++) {
            ctx.fillStyle = Math.random()>0.5?'#000':'#4e342e';
            ctx.fillRect(Math.random()*size,Math.random()*size,Math.random()*60+20,2);
        }
        ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1.0;

        if(!isInner) {
            // å…‰å½±
            const grad = ctx.createRadialGradient(size/2,size/2,size*0.3,size/2,size/2,size*0.9);
            grad.addColorStop(0,'rgba(0,0,0,0)'); grad.addColorStop(1,'rgba(0,0,0,0.5)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,size,size);
            
            // åŒ…é‡‘è¾¹æ¡†
            const r=60; const p=20;
            ctx.beginPath(); ctx.moveTo(p+r,p); ctx.arcTo(size-p,p,size-p,size-p,r); ctx.arcTo(size-p,size-p,p,size-p,r); ctx.arcTo(p,size-p,p,p,r); ctx.arcTo(p,p,size-p,p,r);
            ctx.lineWidth=26; ctx.strokeStyle='#ffd700'; ctx.stroke(); // ç²—é‡‘è¾¹
            
            // è£…é¥°çº¿
            ctx.lineWidth=4; ctx.strokeStyle='#ffe082'; ctx.strokeRect(60,60,size-120,size-120);
            
            // ã€é‡å¤§ä¿®å¤ã€‘ç»˜åˆ¶ç²¾ç¾çš„å¤šå±‚èŠ±ç“£çº¹æ ·ï¼ˆèŠ±è“‰ï¼‰
            const m = size / 2; // ä¸­å¿ƒç‚¹
            ctx.strokeStyle = '#d4af37';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.shadowBlur = 5;
            ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
            
            // è²èŠ±/èŠ™è“‰çº¹æ ·çš„é¢œè‰²æ¸å˜è®¾è®¡
            const baseColor = new THREE.Color(colorHex);
            const secondaryColor = new THREE.Color(0xFFD700); // é‡‘è‰²
            
            const gradientColors = [
                `rgb(${Math.round(baseColor.r*255)}, ${Math.round(baseColor.g*255)}, ${Math.round(baseColor.b*255)})`, // ä¸»è‰²
                `rgb(${Math.round(baseColor.r*180)}, ${Math.round(baseColor.g*180)}, ${Math.round(baseColor.b*180)})`, // ä¸»è‰²æ·±
                `rgb(${Math.round(secondaryColor.r*255)}, ${Math.round(secondaryColor.g*255)}, ${Math.round(secondaryColor.b*255)})`, // é‡‘è‰²
            ];
            
            // ç»˜åˆ¶å¤šå±‚èŠ±ç“£ç»“æ„
            const petalLayers = 3;
            const maxRadius = 100;
            const petalCount = 12; // æ›´å¤šçš„èŠ±ç“£
            
            for (let layer = petalLayers; layer >= 1; layer--) {
                const layerRadius = maxRadius * (layer / petalLayers);
                const colorIndex = (layer - 1) % gradientColors.length;
                ctx.strokeStyle = gradientColors[colorIndex];
                ctx.lineWidth = 2 + layer; // å¤–å±‚æ›´ç²—
                
                ctx.beginPath();
                for (let i = 0; i < petalCount; i++) {
                    const angle = (i * 2 * Math.PI) / petalCount + (layer % 2 === 0 ? 0 : Math.PI / petalCount); // é”™å¼€å±‚æ¬¡
                    
                    const controlRadius = layerRadius * 0.7; 
                    const tipRadius = layerRadius * 1.1; 
                    
                    const startX = m + controlRadius * Math.cos(angle - 0.2);
                    const startY = m + controlRadius * Math.sin(angle - 0.2);
                    
                    const controlX = m + tipRadius * Math.cos(angle);
                    const controlY = m + tipRadius * Math.sin(angle);
                    
                    const endX = m + controlRadius * Math.cos(angle + 0.2);
                    const endY = m + controlRadius * Math.sin(angle + 0.2);
                    
                    // ä»ä¸­å¿ƒç‚¹å¼€å§‹ç»˜åˆ¶ï¼Œå½¢æˆå«è“„çš„å¼§å½¢èŠ±ç“£
                    ctx.moveTo(m, m);
                    ctx.quadraticCurveTo(controlX, controlY, m + layerRadius * Math.cos(angle), m + layerRadius * Math.sin(angle));
                }
                ctx.stroke();
            }

            // ä¸­å¿ƒèŠ±è•Š
            ctx.beginPath();
            ctx.arc(m, m, 12, 0, Math.PI * 2);
            ctx.fillStyle = '#ffe082';
            ctx.fill();
            
            ctx.shadowBlur = 0; // é‡ç½®é˜´å½±
            
        } else {
             // å†…éƒ¨é¢æš—è§’
             const grad = ctx.createRadialGradient(size/2,size/2,size*0.2,size/2,size/2,size*0.9);
             grad.addColorStop(0,'rgba(0,0,0,0)'); grad.addColorStop(1,'rgba(0,0,0,0.9)');
             ctx.fillStyle = grad; ctx.fillRect(0,0,size,size);
        }

        const tex = new THREE.CanvasTexture(canvas); tex.anisotropy=8;
        this.cache[k] = tex; return tex;
    },
    // åˆ›å»ºæ ¸å¿ƒçº¹ç†
    createObsidian() {
        if(this.cache['obs']) return this.cache['obs'];
        const size = 512; const canvas = document.createElement('canvas'); canvas.width=size; canvas.height=size;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#000000'; ctx.fillRect(0,0,size,size);
        // ç†”å²©é‡‘è£‚çº¹
        ctx.strokeStyle = '#ffaa00'; ctx.lineWidth=4; ctx.lineCap='round'; ctx.shadowBlur=10; ctx.shadowColor='#ffaa00';
        ctx.beginPath();
        ctx.moveTo(100,100); ctx.bezierCurveTo(200,150,300,50,400,100);
        ctx.moveTo(50,400); ctx.bezierCurveTo(150,300,350,450,450,350);
        ctx.stroke();
        
        // ç¬¦æ–‡
        ctx.strokeStyle = 'rgba(255,215,0,0.5)'; ctx.lineWidth=2; ctx.shadowBlur=0;
        ctx.strokeRect(150,150,212,212);
        ctx.beginPath(); ctx.arc(256,256,60,0,Math.PI*2); ctx.stroke();

        const tex = new THREE.CanvasTexture(canvas);
        this.cache['obs'] = tex; return tex;
    }
};

/* 3. æ¸¸æˆæ ¸å¿ƒ */
class CoreGame {
    constructor() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x050505);
        // ç§»é™¤é›¾åŒ–æ•ˆæœï¼Œä½¿äº®åº¦ä¸éšè·ç¦»å˜åŒ–
        // this.scene.fog = new THREE.FogExp2(0x050505, 0.06); 

        // è®¡æ—¶å™¨å±æ€§
        this.isTiming = false;
        this.startTime = 0;
        this.elapsedTime = 0;
        this.timerDisplay = document.getElementById('timer-display');


        // 3x3 è§†è§’æ‹‰è¿‘
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
        this.camera.position.set(6, 5, 7); 
        
        this.renderer = new THREE.WebGLRenderer({antialias:true, alpha:true, powerPreference:"high-performance"});
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 120Hz ä¼˜åŒ–
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.2;
        document.body.appendChild(this.renderer.domElement);

        // è¿›ä¸€æ­¥å¢å¼ºç¯å…‰å¼ºåº¦
        this.scene.add(new THREE.AmbientLight(0xffffff, 0.7)); // ç¯å¢ƒå…‰ä» 0.5 æé«˜åˆ° 0.7
        const spot = new THREE.SpotLight(0xffeeb1, 3.5); // èšå…‰ç¯ä» 2.5 æé«˜åˆ° 3.5
        spot.position.set(8, 12, 8); spot.castShadow = true;
        spot.shadow.mapSize.width = 2048; spot.shadow.mapSize.height = 2048;
        this.scene.add(spot);
        const rim = new THREE.PointLight(0x4466ff, 1.0); // è¾¹ç¼˜å…‰ç•¥å¾®æé«˜
        rim.position.set(-5, 0, -5); this.scene.add(rim);

        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;

        this.blocks = [];
        this.gap = new THREE.Vector3();
        this.animating = false;
        
        // ç”¨äºé˜²æ­¢æ‹–åŠ¨è§†è§’æ—¶è§¦å‘æ–¹å—ç§»åŠ¨çš„å±æ€§
        this.isDragging = false;
        this.startMouse = new THREE.Vector2();
        
        this.initMaterials();
        this.initLevel();
        
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.setupEvents(); // ç»Ÿä¸€ç®¡ç†äº‹ä»¶ç›‘å¬å™¨
        
        // ç¡®ä¿è®¡æ—¶å™¨æ˜¾ç¤ºä¸º 00:00
        this.updateTimerDisplay(0);

        window.addEventListener('resize', ()=>{
            this.camera.aspect = window.innerWidth/window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        this.animate();
    }
    
    // æ ¼å¼åŒ–æ—¶é—´å‡½æ•°
    updateTimerDisplay(timeInSeconds) {
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = Math.floor(timeInSeconds % 60);
        const m = String(minutes).padStart(2, '0');
        const s = String(seconds).padStart(2, '0');
        this.timerDisplay.textContent = `${m}:${s}`;
    }

    // è®¾ç½®é¼ æ ‡äº‹ä»¶æ¥åŒºåˆ†ç‚¹å‡»å’Œæ‹–åŠ¨
    setupEvents() {
        window.addEventListener('pointerdown', (e) => {
            this.isDragging = false;
            if (e.button === 0 || e.pointerType === 'touch') {
                this.startMouse.set(e.clientX, e.clientY);
            }
        });
        window.addEventListener('pointermove', (e) => {
            if (!this.startMouse.x) return;
            const dist = Math.hypot(e.clientX - this.startMouse.x, e.clientY - this.startMouse.y);
            if(dist > 5) this.isDragging = true;
        });

        window.addEventListener('pointerup', (e) => {
            if (this.isDragging || e.target.closest('button') || e.target.closest('#sound-menu')) {
                this.isDragging = false;
                return;
            }
            this.onClick(e);
        });
    }

    initMaterials() {
        // å†…ä¾§é¢œè‰² IN:0x3a322e (å·²æäº®)
        const colors = { U:0xe6e6e6, D:0xffd700, R:0xb90000, L:0xff5900, F:0x009e60, B:0x0045ad, IN:0x3a322e }; 
        this.mats = {};
        for(let k in colors) {
            const isInner = k==='IN';
            const t = TextureFactory.createWood(colors[k], isInner);
            this.mats[k] = new THREE.MeshStandardMaterial({
                map:t, roughness: isInner?0.9:0.2, metalness: isInner?0.0:0.2,
                bumpMap:t, bumpScale:0.01
            });
        }
        const obs = TextureFactory.createObsidian();
        this.coreMat = new THREE.MeshStandardMaterial({
            map: obs, color: 0xffffff, roughness: 0.1, metalness: 0.6, emissive: 0x331100, emissiveIntensity: 0.5
        });
    }

    initLevel() {
        this.blocks.forEach(b => this.scene.remove(b.mesh));
        this.blocks = [];
        if(this.fixedCore) this.scene.remove(this.fixedCore);

        // åœ†è§’å‡ ä½•ä½“ï¼šå¤§å°0.96ï¼Œé—´éš™å¾ˆå°ï¼Œçœ‹èµ·æ¥å¾ˆç´§å‡‘
        const geo = new THREE.RoundedBoxGeometry(0.96, 0.96, 0.96, 4, 0.12);

        // 3x3 å¾ªç¯
        for(let z=-1; z<=1; z++) {
            for(let y=-1; y<=1; y++) {
                for(let x=-1; x<=1; x++) {
                    
                    // 1. æ ¸å¿ƒï¼š(0,0,0) æ˜¯å›ºå®šçš„
                    if (x===0 && y===0 && z===0) {
                        const cGeo = new THREE.RoundedBoxGeometry(0.8, 0.8, 0.8, 4, 0.15);
                        this.fixedCore = new THREE.Mesh(cGeo, this.coreMat);
                        this.fixedCore.position.set(0,0,0);
                        // æ ¸å¿ƒå†…éƒ¨å‘å…‰
                        this.fixedCore.add(new THREE.PointLight(0xffaa00, 1.5, 4));
                        this.scene.add(this.fixedCore);
                        continue; // æ ¸å¿ƒä¸åŠ å…¥ blocksï¼Œä¸å¯ç§»åŠ¨
                    }

                    // 2. ç¼ºå£ï¼š(1,1,1) åˆå§‹ä¸ºç©º
                    if (x===1 && y===1 && z===1) {
                        this.gap.set(x,y,z);
                        continue;
                    }

                    // 3. æ™®é€šæ–¹å— (26 - 1 = 25 ä¸ª)
                    const mats = [
                        x===1 ? this.mats.R : this.mats.IN, // Right
                        x===-1 ? this.mats.L : this.mats.IN, // Left
                        y===1 ? this.mats.U : this.mats.IN, // Up
                        y===-1 ? this.mats.D : this.mats.IN, // Down
                        z===1 ? this.mats.F : this.mats.IN, // Front
                        z===-1 ? this.mats.B : this.mats.IN  // Back
                    ];
                    
                    const mesh = new THREE.Mesh(geo, mats);
                    mesh.position.set(x, y, z);
                    mesh.castShadow = true; mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    
                    this.blocks.push({
                        mesh: mesh,
                        solved: new THREE.Vector3(x, y, z)
                    });
                }
            }
        }
    }

    onClick(e) {
        if(document.getElementById('victory-overlay').classList.contains('show')) return;
        if(this.animating) return;

        this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        this.raycaster.setFromCamera(this.mouse, this.camera);

        // åªèƒ½ç‚¹å‡»ç§»åŠ¨æ–¹å—
        const intersects = this.raycaster.intersectObjects(this.blocks.map(b=>b.mesh));

        if(intersects.length > 0) {
            const blk = this.blocks.find(b => b.mesh === intersects[0].object);
            if(blk) this.move(blk);
        }
    }

    move(blk) {
        const dist = blk.mesh.position.distanceTo(this.gap);
        
        if(dist > 0.9 && dist < 1.1) {
            // ã€è®¡æ—¶é€»è¾‘ã€‘å¦‚æœè®¡æ—¶æœªå¼€å§‹ï¼Œåˆ™å¼€å§‹è®¡æ—¶
            if (!this.isTiming) {
                this.isTiming = true;
                this.startTime = Date.now();
            }
            
            // å¯ä»¥ç§»åŠ¨
            audioMgr.play(); // æ’­æ”¾å½“å‰é€‰ä¸­çš„éŸ³æ•ˆ
            this.animating = true;
            
            const targetPos = this.gap.clone();
            this.gap.copy(blk.mesh.position);
            
            new TWEEN.Tween(blk.mesh.position).to(targetPos, 130)
                .easing(TWEEN.Easing.Cubic.Out)
                .onComplete(() => {
                    this.animating = false;
                    this.checkWin();
                }).start();
        } else {
            // æ— æ•ˆç§»åŠ¨æˆ–è¯¯è§¦æ—¶ï¼Œå®Œå…¨é™éŸ³
        }
    }

    reset() {
        TWEEN.removeAll();
        this.animating = false;
        document.getElementById('victory-overlay').classList.remove('show');
        this.initLevel();
        // ã€è®¡æ—¶é€»è¾‘ã€‘é‡ç½®è®¡æ—¶å™¨
        this.isTiming = false;
        this.startTime = 0;
        this.elapsedTime = 0;
        this.updateTimerDisplay(0);
    }

    shuffle() {
        this.reset();
        // ã€è®¡æ—¶é€»è¾‘ã€‘ä¹±é˜µæ—¶ï¼Œé‡ç½®è®¡æ—¶å™¨ï¼ˆresetä¸­å·²å®ç°ï¼‰
        let steps = 60;
        const run = () => {
            if(steps <= 0) return;
            const neighbors = this.blocks.filter(b => b.mesh.position.distanceTo(this.gap) < 1.1);
            if(neighbors.length > 0) {
                const r = neighbors[Math.floor(Math.random() * neighbors.length)];
                const temp = this.gap.clone();
                this.gap.copy(r.mesh.position);
                r.mesh.position.copy(temp);
            }
            steps--;
            setTimeout(run, 15);
        };
        run();
    }

    checkWin() {
        if(this.animating) return;
        let win = true;
        for(let b of this.blocks) {
            if(b.mesh.position.distanceTo(b.solved) > 0.05) {
                win = false; break;
            }
        }
        if(win) {
            document.getElementById('victory-overlay').classList.add('show');
            audioMgr.playWin();
            // ã€è®¡æ—¶é€»è¾‘ã€‘è§£è°œæˆåŠŸï¼Œåœæ­¢è®¡æ—¶
            this.isTiming = false;
        }
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        TWEEN.update();
        
        // ã€è®¡æ—¶é€»è¾‘ä¿®å¤ã€‘åªæœ‰åœ¨isTimingä¸ºtrueæ—¶æ‰ç´¯ç§¯æ—¶é—´
        if (this.isTiming) {
            this.elapsedTime = (Date.now() - this.startTime) / 1000;
            // æ— è®º controls æ˜¯å¦æ´»åŠ¨ï¼ˆæ˜¯å¦å¹³ç§»è§†è§’ï¼‰ï¼Œæ—¶é—´éƒ½åº”æŒç»­ç´¯ç§¯å’Œæ˜¾ç¤º
            this.updateTimerDisplay(this.elapsedTime);
        }

        this.controls.update();
        
        // æ ¸å¿ƒè‡ªè½¬ç‰¹æ•ˆ (åœ¨ç¼éš™ä¸­å¯è§)
        if(this.fixedCore) {
            this.fixedCore.rotation.y -= 0.005;
            this.fixedCore.rotation.x += 0.002;
        }
        
        this.renderer.render(this.scene, this.camera);
    }
}

function toggleMenu() { document.getElementById('sound-menu').classList.toggle('open'); }

const game = new CoreGame();
</script>
</body>
</html>